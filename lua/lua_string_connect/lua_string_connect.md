##lua字符串连接之祸

###题记
我们游戏的后台，使用了lua脚本写一些逻辑。日志模块由c++导出函数到lua　vm 使用，提供了多个日志等级。在日常的开发调试中，我们会把trace/debug等日志打开，以便详细观察定位问题；　而生产环境下，默认的日志等级较高，将不打印trace/debug等。


###起因
某个版本更新后，外网CPU各种100%，居高不下，而所加功能并不算多，逻辑不算复杂。

###经过
使用perf系列工具定位，发现相比之前，有个lua函数调用占比上升明显，并且高居榜首。

`lj_str_new`

(因为事发较久，当时截图已经木有了）。

很悲剧的是，若是c/c++的代码，定位问题热点会容易得多，但是，在lua里，我们无法知道具体是哪个lua函数的调用导致。只好打开lua源码（其实是LuaJIT源码），翻看调用lj_str_new的地方。

这东西在挺多地方调用了的:

``` lj_lib.c
lj_bcread.c
lj_trace.c
...
lj_ctype.c
lj_parse.c
lib_string.c
lj_api.c
```

如此，一时又没了头绪。（只怪自己对lua源码未通读，这个作为以后的一个任务吧）

有一酷爱打日志的同事说，是否因为lua日志问题呢？　死马权当活马医，说时迟那时快，他已经把他那个模块的日志删除了一些。顿时CPU曲线如瀑布般下跌到50%以下。
所删除的日志，后人记录之：

`CommUtil.debug("card fate add value|".."FateID="..iFateID.."FateHP="..iFateHP..",FateAttack="..iFateAttack..省略众多..)`

哦，难怪。我似乎知道了为什么lj_str_new占比这么高的原由了。

###结果
总结一下：
１）日志库，利用了c/c++中宏展开时计算日志等级而跳过的做法。故可以无消耗的屏蔽掉那些在生产环境不需要打印的日志并且对性能无影响。无需vprintf等解析和执行参数入栈或者函数调用。
２）当此库导入到lua使用时，因为。。。（原因你自己想），便会执行字符串连接（其内部原理是lj_str_new？)，而不管是否最终是否打印此日志。

###解决
我想了个简单做法，将导出的debug()函数在一定条件下，替换为空。只需要
`debug = function() end`

何时替换？毕竟我们测试环境debug还是免不了的。

方法：通过系统环境变量定义日志级别，然后在lua初始化时读取系统环境变量，当将环境变量不是`LOG_LEVEL＝debug`时，我们就`debug　= function() end`。

###验证
有几个东西需要经过验证的：

其一：是否`debug=function() end`这种做法能使lua跳过其字符串连接环节。 这个有两种办法，一是仔细研读源码，二是写测试程序。很显然，我选择了２（代码略）。测试结果我其实将信将疑。到底有没有效呢？

其二：不管如何，本着至少不会比原来坏的想法，将这个方案实施并且发布到外网环境。CPU使用情况下降25%。让人惊叹！如下图：（版本发布前后在线基本一致，其中一台大区的CPU利用率情况。）

###总结
我本想自己总结的，但看到云风曾经提醒过的一句话，作为此文的结语吧。 

* 字符串连接操作，会产生新的对象。这是由lua本身的string管理机制导致的。*




